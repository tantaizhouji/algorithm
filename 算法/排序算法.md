# 排序算法

## 排序算法的稳定性

稳定性是指同样大小的样本在排序之后不会改变相对次序

对基础类型来说，稳定性毫无意义

对非基础类型来说，稳定性有重要意义

有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的

|          | 时间复杂度 | 额外空间复杂度 | 稳定性 |
| :------: | :--------: | :------------: | :----: |
| 选择排序 |   O(N^2)   |      O(1)      |   无   |
| 冒泡排序 |   O(N^2)   |      O(1)      |   有   |
| 插入排序 |   O(N^2)   |      O(1)      |   有   |
| 归并排序 | O(N*logN)  |      O(N)      |   有   |
| 随机快排 | O(N*logN)  |    O(logN)     |   无   |
|  堆排序  | O(N*logN)  |      O(1)      |   无   |
|          |            |                |        |
| 计数排序 |    O(N)    |      O(M)      |   有   |
| 基数排序 |    O(N)    |      O(N)      |   有   |

## 排序算法总结

1. 不基于比较的排序,对样本数据有严格要求，不易改写
2. 基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
3. 基于比较的排序，时间复杂度的极限是O(N*logN)
4. 时间复杂度是O(N*logN)，额外空间复杂度低于O(N)，且稳定的基于比较的排序是不存在的
5. 为了绝对的速度选快排，为了省空间选堆排，为了稳定性选归并

### 常见的坑

1. 归并排序的额外空间复杂度可以变成O(1)，"归并排序 内部缓存法"，但是将变得不稳定。不如用堆排
2. "原地归并排序"是垃圾贴，会让时间复杂度变成O(N^2)。不如插入，冒泡
3. 快速排序稳定性改进，"01 stable sort"，但是会对样本数据要求更多。不如用桶排序